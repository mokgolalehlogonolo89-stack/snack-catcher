<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snack Catcher ‚Äî Funny Arcade</title>
<style>
  :root{
    --bg1: #081229;
    --bg2: #0b2b3a;
    --accent: #ffdd57;
    --accent2: #ff6b6b;
    --panel: rgba(255,255,255,0.06);
    --glass: rgba(255,255,255,0.03);
    --text: #f6f8ff;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    background: radial-gradient(1200px 800px at 10% 20%, rgba(12,33,62,0.55) 0%, transparent 25%),
                linear-gradient(180deg,var(--bg1),var(--bg2));
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
  }
  .frame{
    width:100%;
    max-width:1000px;
    aspect-ratio:16/9;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:16px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
    position:relative;
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  header{
    padding:12px 16px;
    display:flex;
    gap:12px;
    align-items:center;
  }
  .logo{
    display:flex;
    align-items:center;
    gap:10px;
  }
  .badge{
    width:46px;height:46px;border-radius:10px;
    background: linear-gradient(135deg,var(--accent),#ff9f43);
    display:flex;align-items:center;justify-content:center;
    font-weight:800;color:#1b1b1b;font-size:20px;
    box-shadow: 0 6px 14px rgba(255,173,51,0.12);
  }
  h1{font-size:18px;margin:0;letter-spacing:0.4px;}
  .controls{
    margin-left:auto;
    display:flex;gap:10px;align-items:center;
  }
  .btn{
    background:var(--panel);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
    color:var(--text);cursor:pointer;font-weight:600;font-size:13px;
  }
  canvas{flex:1;display:block;width:100%;height:100%;background:transparent;}
  .hud{
    position:absolute;left:12px;top:76px;background:var(--glass);padding:10px;border-radius:10px;
    backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,0.02);
  }
  .hud .row{display:flex;gap:10px;align-items:center;margin-bottom:6px;}
  .small{font-size:13px;color:rgba(255,255,255,0.8)}
  .big{font-size:20px;font-weight:800}
  .footer{
    padding:10px 16px;display:flex;gap:12px;align-items:center;justify-content:space-between;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
  }
  .hint{opacity:0.85;font-size:13px}
  .center-ui{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    display:flex;flex-direction:column;align-items:center;gap:12px;text-align:center;
  }
  .panel{
    background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);
  }
  .start-btn{
    padding:12px 18px;border-radius:12px;background:linear-gradient(180deg,var(--accent),#ff9f43);
    color:#121212;font-weight:800;border:none;cursor:pointer;font-size:16px;
    box-shadow:0 8px 24px rgba(255,150,30,0.14);
  }
  .muted{opacity:0.7;font-size:13px}
  @media (max-width:600px){
    .frame{border-radius:10px}
    .badge{width:38px;height:38px;font-size:16px}
  }
</style>
</head>
<body>
<div class="frame" role="application" aria-label="Snack Catcher Game">
  <header>
    <div class="logo">
      <div class="badge">üç™</div>
      <div>
        <h1>Snack Catcher</h1>
        <div class="muted" style="font-size:12px">Catch snacks. Avoid rotten food. Get silly power-ups.</div>
      </div>
    </div>
    <div class="controls">
      <button class="btn" id="helpBtn" title="How to play">How to play</button>
      <button class="btn" id="muteBtn" title="Toggle sound">üîä</button>
      <button class="btn" id="resetBtn" title="Reset high score">Reset HS</button>
    </div>
  </header>

  <canvas id="gameCanvas"></canvas>

  <div class="hud" id="hud">
    <div class="row">
      <div class="small">Score</div>
      <div class="big" id="score">0</div>
    </div>
    <div class="row">
      <div class="small">Lives</div>
      <div class="big" id="lives">3</div>
    </div>
    <div class="row">
      <div class="small">Level</div>
      <div class="big" id="level">1</div>
    </div>
  </div>

  <div class="footer">
    <div class="hint">Controls: Move with mouse / touch / ‚Üê ‚Üí / tap. Catch snacks, avoid rotten ones. Catch combos for extra points!</div>
    <div style="display:flex;gap:12px;align-items:center">
      <div class="small">High score: <span id="highscore">0</span></div>
      <div class="small muted">Made with ‚ù§Ô∏è and JS</div>
    </div>
  </div>

  <div class="center-ui" id="centerUI">
    <div class="panel" id="welcome">
      <h2 style="margin:0 0 6px 0">Welcome, Snack Hero!</h2>
      <p class="muted" style="margin:0 0 12px 0">Catch the good stuff. Avoid the rotten. Press Start (or tap) to begin.</p>
      <button class="start-btn" id="startBtn">Start Game</button>
    </div>

    <div class="panel" id="gameOver" style="display:none">
      <h2 id="goTitle">You ran out of snacks!</h2>
      <div class="muted" id="finalScore">Score: 0</div>
      <div style="height:8px"></div>
      <button class="start-btn" id="retryBtn">Play Again</button>
    </div>
  </div>
</div>

<script>
/* Snack Catcher ‚Äî Single-file canvas game
   Features:
   - Smooth canvas rendering
   - Player basket follows mouse/touch/arrow keys
   - Falling items: snacks, rotten, power-ups
   - Particle effects and confetti
   - Procedural sounds (WebAudio)
   - LocalStorage highscore
   - Mobile + desktop friendly
*/

// ---- Config
const config = {
  gravity: 0.18,
  spawnInterval: 900, // ms
  canvasPadding: 20,
  startLives: 3,
  levelUpScore: 250,
  maxParticles: 120,
  itemSizeRange: [28, 52],
  powerupChance: 0.08,
  rottenChance: 0.14,
  snackPoints: 10,
  comboMultiplierWindow: 900, // ms
};

// ---- Utilities
const rand = (a,b) => Math.random()*(b-a)+a;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const choose = arr => arr[Math.floor(Math.random()*arr.length)];
const now = ()=>performance.now();

function format(n){return Math.round(n)}

// ---- Audio (small procedural SFX)
class SFX {
  constructor(){ this.ctx = null; this.muted=false; }
  init(){
    if(this.ctx) return;
    try{
      const Ctx = window.AudioContext || window.webkitAudioContext;
      this.ctx = new Ctx();
    }catch(e){
      this.ctx = null;
    }
  }
  play(freq=440, type='sine', dur=0.12, vol=0.12){
    if(this.muted) return;
    this.init();
    if(!this.ctx) return;
    const t=this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(t); o.stop(t+dur+0.02);
  }
  click(){ this.play(880,'sawtooth',0.06,0.08); }
  good(){ this.play(950,'triangle',0.12,0.12); }
  bad(){ this.play(160,'sine',0.26,0.18); }
  power(){ this.play(1200,'sine',0.22,0.14); }
}
const sfx = new SFX();

// ---- Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:true });

let W = 1280, H = 720;
function resize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  W = rect.width; H = rect.height - 120; // leave header/footer
  canvas.width = Math.max(300, Math.floor(W * devicePixelRatio));
  canvas.height = Math.max(200, Math.floor((rect.height - 120) * devicePixelRatio));
  canvas.style.width = rect.width + 'px';
  canvas.style.height = (rect.height - 120) + 'px';
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resize);
resize();

// ---- Game state
let state = {
  score:0, lives:config.startLives, level:1, running:false,
  lastSpawn:0, items:[], particles:[], player:null, lastComboTime:0, comboStreak:0,
  highscore: parseInt(localStorage.getItem('snack_highscore') || '0',10) || 0,
  lastTick: now(),
  keys: {left:false,right:false},
};

// update HUD
function updateHUD(){
  document.getElementById('score').textContent = format(state.score);
  document.getElementById('lives').textContent = state.lives;
  document.getElementById('level').textContent = state.level;
  document.getElementById('highscore').textContent = state.highscore;
}

// ---- Player (basket)
class Player {
  constructor(){
    this.x = W/2;
    this.y = H - 38;
    this.w = 130;
    this.h = 40;
    this.targetX = this.x;
    this.speed = 0.2; // interpolation
    this.color = '#ffd66b';
    this.shake = 0;
  }
  update(dt){
    // keyboard smooth input
    if(state.keys.left) this.targetX -= 600 * dt/1000;
    if(state.keys.right) this.targetX += 600 * dt/1000;
    this.targetX = clamp(this.targetX, 40, W - 40);
    this.x += (this.targetX - this.x) * (0.12 + 0.4 * (state.level/8));
    this.y = H - 48;
    this.shake *= 0.92;
  }
  draw(ctx){
    // basket shadow
    ctx.save();
    ctx.translate(this.x, this.y);
    const s = 1 + Math.sin(now()/120) * 0.01;
    ctx.scale(s,s);
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.16)';
    ctx.ellipse(0, 16, this.w*0.62, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // basket body
    ctx.beginPath();
    const grad = ctx.createLinearGradient(-this.w/2, -this.h, this.w/2, this.h);
    grad.addColorStop(0, '#ffd66b'); grad.addColorStop(1, '#ff9f43');
    ctx.fillStyle = grad;
    roundRect(ctx, -this.w/2, -this.h/2, this.w, this.h, 10);
    ctx.fill();

    // basket rim
    ctx.beginPath();
    ctx.fillStyle = '#6b3e1b';
    roundRect(ctx, -this.w/2 - 6, -this.h/2 - 8, this.w + 12, 12, 8);
    ctx.fill();

    // silly sticker
    ctx.font = 'bold 18px system-ui,Segoe UI,Roboto';
    ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillStyle = '#fff';
    ctx.fillText('SNACK', 0, -2);

    ctx.restore();
  }
}

// ---- Items (falling objects)
class Item {
  constructor(opts){
    this.x = opts.x; this.y = opts.y || -40;
    this.vy = opts.vy || rand(40,80);
    this.size = opts.size || rand(...config.itemSizeRange);
    this.kind = opts.kind || 'snack'; // 'snack', 'rotten', 'power'
    this.emoji = opts.emoji || 'üç™';
    this.bonus = opts.bonus || 0;
    this.spin = rand(-0.06, 0.06);
    this.rotation = rand(0, Math.PI*2);
    this.id = Math.random().toString(36).slice(2,9);
    this.color = opts.color || null;
  }
  update(dt){
    this.vy += config.gravity * (0.6 + state.level*0.05);
    this.y += this.vy * dt/16;
    this.rotation += this.spin;
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.font = `${Math.floor(this.size)}px serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    // add shadow and circle behind emoji for better visibility
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.14)';
    ctx.ellipse(0, 6, this.size*0.6, this.size*0.44, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    if(this.kind === 'snack'){
      ctx.fillStyle = this.color || '#fff';
      ctx.fillText(this.emoji, 0, 0);
    } else if(this.kind === 'rotten'){
      ctx.fillStyle = this.color || '#ddd';
      ctx.fillText(this.emoji, 0, 0);
    } else if(this.kind === 'power'){
      ctx.fillStyle = this.color || '#fff';
      ctx.fillText(this.emoji, 0, 0);
      // power rim
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.36)';
      ctx.beginPath();
      ctx.ellipse(0,0,this.size*0.5,this.size*0.5,0,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }
}

// ---- Particles
class Particle {
  constructor(x,y,opts = {}){
    this.x = x; this.y = y;
    this.vx = rand(-120,120); this.vy = rand(-200, -20);
    this.life = opts.life || rand(400, 1000);
    this.size = opts.size || rand(3, 9);
    this.color = opts.color || '#ffde9b';
    this.created = now();
    this.gravity = opts.gravity || 0.18;
  }
  update(dt){
    this.vy += this.gravity;
    this.x += this.vx * dt/1000;
    this.y += this.vy * dt/1000;
  }
  draw(ctx){
    const age = now() - this.created;
    const alpha = 1 - age / this.life;
    if(alpha <= 0) return;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    roundRect(ctx, this.x, this.y, this.size, this.size, 2);
    ctx.restore();
  }
}

// ---- Helpers
function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

// ---- Spawn logic
function spawnItem(){
  const x = rand(40, W-40);
  const size = rand(...config.itemSizeRange);
  const isPower = Math.random() < (config.powerupChance + state.level*0.002);
  const isRotten = !isPower && (Math.random() < (config.rottenChance + state.level*0.01));
  if(isPower){
    const choices = [
      {emoji:'‚ö°', type:'speed'},
      {emoji:'‚≠ê', type:'mult'},
      {emoji:'‚ù§Ô∏è', type:'life'},
      {emoji:'üß≤', type:'magnet'},
    ];
    const p = choose(choices);
    const itm = new Item({x, size, kind:'power', emoji:p.emoji, bonus:p.type, color:'#fff'});
    itm.meta = p.type;
    state.items.push(itm);
  } else if(isRotten){
    const rottenEmojis = ['ü•Ä','ü¶†','üßÄ','ü•¥'];
    state.items.push(new Item({x,size,kind:'rotten',emoji:choose(rottenEmojis),color:'#e0e0e0'}));
  } else {
    const snacks = ['üç™','üç©','üç´','üçï','üçü','üßÅ','üç≠','üçå'];
    state.items.push(new Item({x,size,kind:'snack',emoji:choose(snacks)}));
  }
}

// ---- Collisions
function checkCatch(item){
  const p = state.player;
  // approximate basket as rectangle
  const left = p.x - p.w/2;
  const right = p.x + p.w/2;
  const top = p.y - p.h;
  const bottom = p.y + p.h/2;
  return item.x > left + 10 && item.x < right - 10 && item.y > top && item.y < bottom + 8;
}

// ---- Game logic
function startGame(){
  state.score = 0; state.lives = config.startLives; state.level = 1;
  state.items = []; state.particles = []; state.running = true;
  state.lastSpawn = now();
  state.player = new Player();
  state.lastComboTime = 0; state.comboStreak = 0;
  document.getElementById('centerUI').style.display='none';
  sfx.click();
  updateHUD();
}

function gameOver(){
  state.running = false;
  // show gameover UI
  document.getElementById('centerUI').style.display = 'flex';
  document.getElementById('welcome').style.display = 'none';
  document.getElementById('gameOver').style.display = 'block';
  document.getElementById('finalScore').textContent = 'Final score: ' + format(state.score);
  document.getElementById('goTitle').textContent = state.score > state.highscore ? 'New Snack Legend!' : 'Game Over ‚Äî Snackless';
  if(state.score > state.highscore){
    state.highscore = state.score;
    localStorage.setItem('snack_highscore', String(state.highscore));
  }
  updateHUD();
  sfx.bad();
}

// ---- Effects
function burst(x,y,color,count=18){
  for(let i=0;i<count;i++){
    if(state.particles.length > config.maxParticles) break;
    state.particles.push(new Particle(x,y,{color, life:rand(300,1200), size:rand(3,8)}));
  }
}

function confetti(x,y){
  for(let i=0;i<40;i++){
    const colors = ['#ffd66b','#ff9f43','#8ee3ef','#c1ffbf','#f6a4ff'];
    state.particles.push(new Particle(x + rand(-12,12), y + rand(-12,12), {color: choose(colors), life:rand(800,1400), size:rand(4,9)}));
  }
}

// ---- Main loop
function tick(){
  const t = now();
  const dt = t - state.lastTick;
  state.lastTick = t;

  if(state.running){
    // spawn items
    if(t - state.lastSpawn > Math.max(150, config.spawnInterval - state.level*60)){
      spawnItem();
      state.lastSpawn = t;
    }

    // update player
    state.player.update(dt);

    // update items
    for(let i=state.items.length-1;i>=0;i--){
      const it = state.items[i];
      it.update(dt);
      // check catch
      if(checkCatch(it)){
        // handle kinds
        if(it.kind === 'snack'){
          state.score += config.snackPoints;
          sfx.good();
          burst(it.x, it.y, '#fff', 10);
          // combo logic
          if(t - state.lastComboTime < config.comboMultiplierWindow){
            state.comboStreak++;
            const extra = Math.floor(state.comboStreak * 0.5) * 5;
            state.score += extra;
            // tiny fireworks
            burst(it.x, it.y-10, '#ffd66b', 6);
          } else {
            state.comboStreak = 1;
          }
          state.lastComboTime = t;
        } else if(it.kind === 'rotten'){
          state.lives -= 1;
          state.score = Math.max(0, state.score - 12);
          sfx.bad();
          burst(it.x, it.y, '#bbbbbb', 14);
          state.player.shake = 6;
        } else if(it.kind === 'power'){
          // apply power-ups
          handlePowerUp(it.meta);
          sfx.power();
          confetti(it.x, it.y);
        }
        // remove item
        state.items.splice(i,1);
        updateHUD();
        // level up?
        if(state.score >= state.level * config.levelUpScore){
          state.level++;
          // fun celebration
          confetti(W/2, H/3);
          sfx.play(1200 + state.level*40, 'triangle', 0.3, 0.12);
        }
      } else if(it.y > H + 80){
        // missed good snack reduces life slightly
        if(it.kind === 'snack'){
          state.lives -= 0.5;
          burst(it.x, H-30, '#ffb3b3', 6);
        }
        // remove offscreen
        state.items.splice(i,1);
        updateHUD();
      }
    }

    // update particles
    for(let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.update(dt);
      if(now() - p.created > p.life) state.particles.splice(i,1);
    }

    // lose condition
    if(state.lives <= 0){
      state.lives = 0;
      updateHUD();
      gameOver();
    }
  }

  draw();
  requestAnimationFrame(tick);
}

// ---- Draw
function drawBackground(ctx){
  // animated gradient sky
  const g = ctx.createLinearGradient(0,0,0,H);
  const shift = Math.sin(now()/3000 + state.level) * 0.08;
  g.addColorStop(0, `rgba(12,30,55,${0.9 + shift})`);
  g.addColorStop(1, `rgba(7,19,34,${0.9 - shift*0.8})`);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // ground strip
  const grd = ctx.createLinearGradient(0,H-80,0,H);
  grd.addColorStop(0, 'rgba(0,0,0,0.12)');
  grd.addColorStop(1, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,H-70,W,70);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // scale for device
  drawBackground(ctx);

  // decorative clouds (parallax)
  for(let i=0;i<5;i++){
    const sx = ((now()/800) * (0.2 + i*0.06) + i*200) % (W+300) - 150;
    const sy = 40 + i*18 + Math.sin(now()/1100 + i) * 8;
    drawCloud(ctx, sx, sy, 80 + i*10, 12 + i*3, 0.08 + i*0.02);
  }

  // items
  for(const it of state.items){
    it.draw(ctx);
  }

  // player
  if(state.player) state.player.draw(ctx);

  // particles
  for(const p of state.particles){
    p.draw(ctx);
  }

  // overlay UI subtle glow
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,H-30,W,30);
  ctx.restore();
}

// small cloud drawing (soft)
function drawCloud(ctx,x,y,w,h,alpha=0.12){
  ctx.save();
  ctx.translate(x,y);
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  ctx.beginPath();
  ctx.ellipse(0,0,w*0.6,h*0.6,0,0,Math.PI*2);
  ctx.fill();
  ctx.beginPath(); ctx.ellipse(-w*0.25,6,w*0.4,h*0.36,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(w*0.25,6,w*0.45,h*0.38,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// ---- Power-ups
let activePowers = { magnet: false, mult: false, speed: false, life: false };
let powerTimers = {};

function handlePowerUp(type){
  if(type === 'life'){
    state.lives = Math.min(config.startLives + 2, state.lives + 1);
    sfx.play(900,'sine',0.22,0.12);
  } else {
    activePowers[type] = true;
    powerTimers[type] = now() + 8000 + Math.random()*4000;
    sfx.play(1000,'triangle',0.16,0.08);
  }
}

function updatePowers(){
  const t = now();
  for(const k in powerTimers){
    if(powerTimers[k] < t){
      activePowers[k] = false;
      delete powerTimers[k];
    }
  }
  // if magnet active, attract snacks
  if(activePowers.magnet){
    for(const it of state.items){
      if(it.kind === 'snack'){
        const dx = state.player.x - it.x;
        const dist = Math.abs(dx);
        if(dist < 220){
          it.x += dx * 0.06;
        }
      }
    }
  }
}

// ---- Input
let lastTouch = null;
canvas.addEventListener('mousemove', (e)=>{
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left);
  if(state.player) state.player.targetX = clamp(x, 20, W-20);
});
canvas.addEventListener('touchmove', (e)=>{
  e.preventDefault();
  const t = e.touches[0];
  const r = canvas.getBoundingClientRect();
  const x = (t.clientX - r.left);
  if(state.player) state.player.targetX = clamp(x, 20, W-20);
},{passive:false});
canvas.addEventListener('click', (e)=>{
  if(!state.running){
    // start if clicking on canvas
    startGame();
    document.getElementById('centerUI').style.display='none';
  } else {
    // small flick sound
    sfx.click();
  }
});
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd') state.keys.right = true;
  if(e.key === ' ' && !state.running){ startGame(); }
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd') state.keys.right = false;
});

// ---- UI buttons
document.getElementById('startBtn').addEventListener('click', ()=>{ startGame(); });
document.getElementById('retryBtn').addEventListener('click', ()=>{ startGame(); document.getElementById('gameOver').style.display='none'; });
document.getElementById('helpBtn').addEventListener('click', ()=>{ alert("Move your basket with mouse / touch / ‚Üê ‚Üí keys. Catch snacks (üç™üç©üçï) to score points. Avoid rotten food (ü•Äü¶†) ‚Äî they steal lives. Catch power-ups (‚ö°‚≠ê‚ù§Ô∏èüß≤) for temporary boosts. Good luck!"); });
document.getElementById('muteBtn').addEventListener('click', (e)=>{
  sfx.muted = !sfx.muted;
  e.target.textContent = sfx.muted ? 'üîà' : 'üîä';
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(confirm('Reset saved high score?')){ localStorage.removeItem('snack_highscore'); state.highscore = 0; updateHUD(); }
});

// ---- Init
updateHUD();
resize();
state.player = new Player();
requestAnimationFrame(tick);

// periodic power update
setInterval(updatePowers, 220);

// friendly auto-start hint after a little while
setTimeout(()=>{ if(!state.running) document.getElementById('centerUI').style.display='flex'; }, 800);

</script>
</body>
</html>